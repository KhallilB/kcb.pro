name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even if no conventional commits detected'
        required: false
        type: boolean
      target_projects:
        description: 'Specific projects to release (comma-separated, leave empty for all)'
        required: false
        default: ''
      release_type:
        description: 'Override release type (auto uses conventional commits)'
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
        default: auto

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Configure Git
        run: |
          git config --global user.name "release-bot"
          git config --global user.email "release-bot@users.noreply.github.com"

      - name: Install Dependencies
        run: npm install

      - name: Analyze Conventional Commits
        id: analyze
        run: |
          echo "üîç Analyzing conventional commits..."

          # Determine commit range to analyze
          if [ "${{ github.event_name }}" = "push" ]; then
            # For push events (including PR merges), check commits in the push
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              COMMIT_RANGE="${{ github.event.before }}..HEAD"
            else
              # First push to branch
              COMMIT_RANGE="HEAD~1..HEAD"
            fi
          else
            # For manual dispatch, check since last release
            LAST_RELEASE_TAG=$(git tag --list "*@*" --sort=-version:refname | head -1)
            if [ -n "$LAST_RELEASE_TAG" ]; then
              COMMIT_RANGE="${LAST_RELEASE_TAG}..HEAD"
            else
              COMMIT_RANGE="HEAD~10..HEAD"
            fi
          fi

          echo "üìã Analyzing commit range: $COMMIT_RANGE"

          # Check for conventional commits
          CONVENTIONAL_COMMITS=$(git log $COMMIT_RANGE --oneline --grep="^feat" --grep="^fix" --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --grep="^test" --grep="^build" --grep="^ci" --grep="^revert" --grep="BREAKING CHANGE" --extended-regexp)

          # Determine if release is needed
          NEEDS_RELEASE=false
          if [ -n "$CONVENTIONAL_COMMITS" ]; then
            echo "‚úÖ Found conventional commits:"
            echo "$CONVENTIONAL_COMMITS"
            NEEDS_RELEASE=true
          elif [ "${{ github.event.inputs.force_release }}" == "true" ]; then
            echo "‚úÖ Force release requested"
            NEEDS_RELEASE=true
          else
            echo "‚ùå No conventional commits found in range $COMMIT_RANGE"
          fi

          # Check if this is first release
          FIRST_RELEASE=false
          if ! git tag --list "*@*" | head -1 | grep -q "@"; then
            echo "üéâ First release detected"
            FIRST_RELEASE=true
            NEEDS_RELEASE=true
          fi

          # Set outputs
          echo "needs_release=$NEEDS_RELEASE" >> $GITHUB_OUTPUT
          echo "is_first_release=$FIRST_RELEASE" >> $GITHUB_OUTPUT

          # Show current project versions
          echo ""
          echo "üì¶ Current project versions:"
          find . -name "package.json" -path "*/apps/*" -o -path "*/libs/*" -o -path "*/packages/*" | while read file; do
            if [ -f "$file" ]; then
              PROJECT_NAME=$(basename $(dirname "$file"))
              VERSION=$(grep '"version"' "$file" | cut -d'"' -f4)
              echo "  $PROJECT_NAME: $VERSION"
            fi
          done

      - name: Run NX Release
        if: steps.analyze.outputs.needs_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
        run: |
          echo "üöÄ Running NX Release..."

          # Build release command
          RELEASE_CMD="npx nx release --verbose"

          # Add target projects if specified
          if [ -n "${{ github.event.inputs.target_projects }}" ]; then
            RELEASE_CMD="$RELEASE_CMD --projects=${{ github.event.inputs.target_projects }}"
            echo "üéØ Targeting specific projects: ${{ github.event.inputs.target_projects }}"
          fi

          # Add first release flag if needed
          if [ "${{ steps.analyze.outputs.is_first_release }}" == "true" ]; then
            RELEASE_CMD="$RELEASE_CMD --first-release"
            echo "üéâ Running first release"
          fi

          # Add release type override if specified
          if [ "${{ github.event.inputs.release_type }}" != "auto" ] && [ -n "${{ github.event.inputs.release_type }}" ]; then
            RELEASE_CMD="$RELEASE_CMD --specifier=${{ github.event.inputs.release_type }}"
            echo "üìä Using release type override: ${{ github.event.inputs.release_type }}"
          fi

          # Add force flag if needed
          if [ "${{ github.event.inputs.force_release }}" == "true" ]; then
            RELEASE_CMD="$RELEASE_CMD --force"
            echo "üí™ Force release enabled"
          fi

          echo "Executing: $RELEASE_CMD"
          echo ""

          # Execute the release command
          $RELEASE_CMD

          echo ""
          echo "‚úÖ NX Release completed successfully!"

      - name: Verify Release Results
        if: steps.analyze.outputs.needs_release == 'true'
        id: verify
        run: |
          echo "üîç Verifying release results..."

          # Check if any new tags were created
          NEW_TAGS=$(git tag --points-at HEAD | grep "@" || true)

          if [ -n "$NEW_TAGS" ]; then
            echo "‚úÖ New release tags created:"
            echo "$NEW_TAGS" | sed 's/^/  üè∑Ô∏è  /'
            echo "has_new_releases=true" >> $GITHUB_OUTPUT
            
            # Store new tags for use in GitHub releases
            echo "$NEW_TAGS" > /tmp/new_tags.txt
            
            echo ""
            echo "üì¶ Released project versions:"
            echo "$NEW_TAGS" | while read tag; do
              if [ -n "$tag" ]; then
                PROJECT=$(echo "$tag" | cut -d'@' -f1)
                VERSION=$(echo "$tag" | cut -d'@' -f2)
                echo "  $PROJECT: $VERSION"
              fi
            done
          else
            echo "‚ùå No new release tags found"
            echo "has_new_releases=false" >> $GITHUB_OUTPUT
          fi

          # Show what files were changed
          echo ""
          echo "üìù Files modified in this release:"
          git log -1 --name-only --pretty=format: | grep -E '\.(json|md)$' | sed 's/^/  üìÑ /' || echo "  No files modified"

      - name: Create GitHub Releases
        if: steps.verify.outputs.has_new_releases == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Creating GitHub releases..."

          # Read new tags from temporary file
          if [ ! -f "/tmp/new_tags.txt" ]; then
            echo "‚ùå No new tags file found"
            exit 1
          fi

          while read -r TAG; do
            if [ -n "$TAG" ] && echo "$TAG" | grep -q "@"; then
              PROJECT=$(echo "$TAG" | cut -d'@' -f1)
              VERSION=$(echo "$TAG" | cut -d'@' -f2)
              
              echo "Creating GitHub release for $PROJECT v$VERSION..."
              
              # Find changelog file for this project
              CHANGELOG_FILE=""
              for dir in "apps" "libs" "packages"; do
                if [ -f "$dir/$PROJECT/CHANGELOG.md" ]; then
                  CHANGELOG_FILE="$dir/$PROJECT/CHANGELOG.md"
                  break
                fi
              done
              
              # Extract release notes from changelog
              RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release was automatically generated from conventional commits."
              
              if [ -f "$CHANGELOG_FILE" ]; then
                echo "üìÑ Found changelog: $CHANGELOG_FILE"
                
                # Extract the content for this version
                VERSION_CONTENT=$(awk "
                  /^## .*$VERSION/ { flag=1; next }
                  /^## / && flag { exit }
                  flag && !/^$/ { print }
                " "$CHANGELOG_FILE" | head -50)
                
                if [ -n "$VERSION_CONTENT" ]; then
                  RELEASE_NOTES="$VERSION_CONTENT"
                else
                  RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release contains updates to $PROJECT."
                fi
              else
                echo "‚ö†Ô∏è  No changelog found for $PROJECT"
              fi
              
              # Create GitHub release (as draft for review)
              if gh release create "$TAG" \
                --draft \
                --title "$PROJECT v$VERSION" \
                --notes "$RELEASE_NOTES" \
                --generate-notes; then
                echo "‚úÖ Created draft release: $PROJECT v$VERSION"
              else
                echo "‚ùå Failed to create release for $TAG"
              fi
            fi
          done < /tmp/new_tags.txt

          echo ""
          echo "üéâ All GitHub releases created as drafts!"
          echo "üëÄ Review and publish at: https://github.com/${{ github.repository }}/releases"

      - name: Release Summary
        if: always()
        run: |
          echo ""
          echo "üìä Release Workflow Summary"
          echo "=========================="
          echo "üîß Triggered by: ${{ github.event_name }}"
          echo "üåü Release needed: ${{ steps.analyze.outputs.needs_release }}"
          echo "üéØ First release: ${{ steps.analyze.outputs.is_first_release }}"

          if [ "${{ steps.analyze.outputs.needs_release }}" == "true" ]; then
            if [ "${{ steps.verify.outputs.has_new_releases }}" == "true" ]; then
              echo "‚úÖ **SUCCESS**: Release completed!"
              echo ""
              echo "üè∑Ô∏è  **New Tags Created:**"
              git tag --points-at HEAD | grep "@" | sed 's/^/   ‚Ä¢ /' || echo "   None"
              echo ""
              echo "üìù **Next Steps:**"
              echo "   1. Review draft releases: https://github.com/${{ github.repository }}/releases"
              echo "   2. Publish releases when ready"
              echo "   3. Verify deployment pipelines (if any)"
            else
              echo "‚ö†Ô∏è  **WARNING**: Release was attempted but no new versions were created"
              echo "   This might indicate:"
              echo "   ‚Ä¢ No changes detected by NX"
              echo "   ‚Ä¢ Configuration issues"
              echo "   ‚Ä¢ Projects already at correct versions"
            fi
          else
            echo "‚ÑπÔ∏è  **INFO**: No release needed"
            echo ""
            echo "üí° **To trigger a release, use conventional commits:**"
            echo "   ‚Ä¢ feat: new feature (minor bump)"
            echo "   ‚Ä¢ fix: bug fix (patch bump)"
            echo "   ‚Ä¢ feat!: breaking change (major bump)"
            echo "   ‚Ä¢ chore, docs, style, etc. (patch bump)"
            echo ""
            echo "üîß **Or use manual trigger:**"
            echo "   ‚Ä¢ Go to Actions ‚Üí Release ‚Üí Run workflow"
            echo "   ‚Ä¢ Enable 'Force release' option"
          fi
