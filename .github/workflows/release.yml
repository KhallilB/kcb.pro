name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even if no conventional commits detected'
        required: false
        type: boolean
      target_projects:
        description: 'Specific projects to release (comma-separated, leave empty for all)'
        required: false
        default: ''
      release_type:
        description: 'Override release type (auto uses conventional commits)'
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
        default: auto

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Configure Git
        run: |
          git config --global user.name "release-bot"
          git config --global user.email "release-bot@users.noreply.github.com"

      - name: Install Dependencies
        run: npm install

      - name: Analyze Conventional Commits
        id: analyze
        run: |
          echo "üîç Analyzing conventional commits..."

          # Determine commit range to analyze
          if [ "${{ github.event_name }}" = "push" ]; then
            # For push events (including PR merges), check commits in the push
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              COMMIT_RANGE="${{ github.event.before }}..HEAD"
            else
              # First push to branch
              COMMIT_RANGE="HEAD~1..HEAD"
            fi
          else
            # For manual dispatch, check since last release per project
            COMMIT_RANGE="HEAD~10..HEAD"  # fallback range
          fi

          echo "üìã Analyzing commit range: $COMMIT_RANGE"

          # Show the commits we're analyzing
          echo "üìù Commits in range:"
          git log $COMMIT_RANGE --oneline | sed 's/^/  /'

          # Check for conventional commits in the range
          CONVENTIONAL_COMMITS=$(git log $COMMIT_RANGE --oneline --grep="^feat" --grep="^fix" --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --grep="^test" --grep="^build" --grep="^ci" --grep="^revert" --grep="BREAKING CHANGE" --extended-regexp)

          # Also check each commit message for conventional format (handles squash merges)
          MANUAL_CHECK_COMMITS=$(git log $COMMIT_RANGE --pretty=format:"%h %s" | grep -E "^[a-f0-9]+ (feat|fix|chore|docs|style|refactor|perf|test|build|ci)(\(.+\))?:")

          # Also check for conventional commits since last release for each project
          echo ""
          echo "üîç Checking per-project since last release:"
          PROJECT_HAS_CHANGES=false

          for project in router home shared; do
            LAST_TAG=$(git tag --list "${project}@*" --sort=-version:refname | head -1)
            if [ -n "$LAST_TAG" ]; then
              echo "  $project (since $LAST_TAG):"
              PROJECT_COMMITS=$(git log ${LAST_TAG}..HEAD --oneline --grep="^feat" --grep="^fix" --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --grep="^test" --grep="^build" --grep="^ci" --grep="BREAKING CHANGE" --extended-regexp)
              
              # Also check for any commits affecting this project's files
              PROJECT_FILE_CHANGES=$(git log ${LAST_TAG}..HEAD --oneline --name-only | grep -E "(apps/${project}/|libs/${project}/|packages/${project}/)" | wc -l)
              
              if [ -n "$PROJECT_COMMITS" ] || [ "$PROJECT_FILE_CHANGES" -gt 0 ]; then
                echo "    ‚úÖ Changes detected"
                if [ -n "$PROJECT_COMMITS" ]; then
                  echo "$PROJECT_COMMITS" | sed 's/^/      /'
                fi
                if [ "$PROJECT_FILE_CHANGES" -gt 0 ]; then
                  echo "      üìÅ $PROJECT_FILE_CHANGES file(s) changed"
                fi
                PROJECT_HAS_CHANGES=true
              else
                echo "    ‚ùå No changes detected"
              fi
            else
              echo "  $project: No previous releases (will release)"
              PROJECT_HAS_CHANGES=true
            fi
          done

          # Determine if release is needed
          NEEDS_RELEASE=false
          if [ -n "$CONVENTIONAL_COMMITS" ] || [ -n "$MANUAL_CHECK_COMMITS" ] || [ "$PROJECT_HAS_CHANGES" = "true" ]; then
            echo ""
            echo "‚úÖ Found changes requiring release:"
            [ -n "$CONVENTIONAL_COMMITS" ] && echo "$CONVENTIONAL_COMMITS" | sed 's/^/  üìù /'
            [ -n "$MANUAL_CHECK_COMMITS" ] && echo "$MANUAL_CHECK_COMMITS" | sed 's/^/  üîç /'
            NEEDS_RELEASE=true
          elif [ "${{ github.event.inputs.force_release }}" == "true" ]; then
            echo "‚úÖ Force release requested"
            NEEDS_RELEASE=true
          else
            echo "‚ùå No conventional commits or changes found"
          fi

          # Check if this is first release
          FIRST_RELEASE=false
          if ! git tag --list "*@*" | head -1 | grep -q "@"; then
            echo "üéâ First release detected"
            FIRST_RELEASE=true
            NEEDS_RELEASE=true
          fi

          # Set outputs
          echo "needs_release=$NEEDS_RELEASE" >> $GITHUB_OUTPUT
          echo "is_first_release=$FIRST_RELEASE" >> $GITHUB_OUTPUT
          echo "commit_range=$COMMIT_RANGE" >> $GITHUB_OUTPUT

          # Show current project versions
          echo ""
          echo "üì¶ Current project versions:"
          for dir in apps libs packages; do
            if [ -d "$dir" ]; then
              find "$dir" -maxdepth 2 -name "package.json" -type f | while read file; do
                if [ -f "$file" ]; then
                  PROJECT_NAME=$(basename $(dirname "$file"))
                  VERSION=$(grep '"version"' "$file" | cut -d'"' -f4 2>/dev/null || echo "unknown")
                  echo "  $PROJECT_NAME: $VERSION"
                fi
              done
            fi
          done

      - name: Determine Release Strategy
        if: steps.analyze.outputs.needs_release == 'true'
        id: strategy
        run: |
          echo "üéØ Determining release strategy..."

          # Analyze the types of conventional commits we found
          COMMIT_RANGE="${{ steps.analyze.outputs.commit_range }}"

          # Check for breaking changes
          BREAKING_CHANGES=$(git log $COMMIT_RANGE --grep="BREAKING CHANGE" --grep="!" --extended-regexp --oneline)

          # Check for features
          FEATURES=$(git log $COMMIT_RANGE --grep="^feat" --extended-regexp --oneline)

          # Check for fixes and other changes
          FIXES=$(git log $COMMIT_RANGE --grep="^fix" --extended-regexp --oneline)
          OTHER_CHANGES=$(git log $COMMIT_RANGE --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --extended-regexp --oneline)

          # Determine version bump type
          if [ -n "$BREAKING_CHANGES" ]; then
            RELEASE_TYPE="major"
            echo "üìà Detected breaking changes - will use MAJOR version bump"
          elif [ -n "$FEATURES" ]; then
            RELEASE_TYPE="minor"
            echo "üìà Detected features - will use MINOR version bump"
          elif [ -n "$FIXES" ] || [ -n "$OTHER_CHANGES" ]; then
            RELEASE_TYPE="patch"
            echo "üìà Detected fixes/changes - will use PATCH version bump"
          else
            RELEASE_TYPE="patch"
            echo "üìà Default to PATCH version bump"
          fi

          # Override if manual release type specified
          if [ "${{ github.event.inputs.release_type }}" != "auto" ] && [ -n "${{ github.event.inputs.release_type }}" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            echo "üéõÔ∏è Manual override: using $RELEASE_TYPE version bump"
          fi

          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "‚úÖ Will use release type: $RELEASE_TYPE"

      - name: Run NX Release
        if: steps.analyze.outputs.needs_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
        run: |
          echo "üöÄ Running NX Release..."
          echo "üîÑ Using individual NX release commands for better control..."

          # Clean git state first
          echo "üßπ Ensuring clean git state..."
          git add package-lock.json || echo "No package-lock.json to add"
          git commit -m "chore: update package-lock.json" || echo "No changes in package-lock.json"

          # Step 1: Version bump
          VERSION_CMD="npx nx release version ${{ steps.strategy.outputs.release_type }} --verbose --git-commit --git-tag"

          # Add target projects if specified
          if [ -n "${{ github.event.inputs.target_projects }}" ]; then
            VERSION_CMD="$VERSION_CMD --projects=${{ github.event.inputs.target_projects }}"
            echo "üéØ Targeting specific projects: ${{ github.event.inputs.target_projects }}"
          fi

          # Add first release flag if needed
          if [ "${{ steps.analyze.outputs.is_first_release }}" == "true" ]; then
            VERSION_CMD="$VERSION_CMD --first-release"
            echo "üéâ Running first release"
          fi

          echo "Executing version: $VERSION_CMD"

          # Try version command
          if $VERSION_CMD; then
            echo "‚úÖ Version bump completed successfully!"
            VERSION_SUCCESS=true
          else
            echo "‚ö†Ô∏è NX version command failed, trying without git integration..."
            echo ""
            
            # Alternative: Version without git, then handle git manually
            ALT_VERSION_CMD="npx nx release version ${{ steps.strategy.outputs.release_type }} --verbose --stage-changes --git-commit=false --git-tag=false"
            if [ -n "${{ github.event.inputs.target_projects }}" ]; then
              ALT_VERSION_CMD="$ALT_VERSION_CMD --projects=${{ github.event.inputs.target_projects }}"
            fi
            if [ "${{ steps.analyze.outputs.is_first_release }}" == "true" ]; then
              ALT_VERSION_CMD="$ALT_VERSION_CMD --first-release"
            fi
            
            echo "Trying alternative: $ALT_VERSION_CMD"
            if $ALT_VERSION_CMD; then
              echo "‚úÖ Alternative version bump succeeded!"
              VERSION_SUCCESS=true
              
              # Manually handle git operations
              echo "üìù Manually handling git operations..."
              git add .
              
              # Create commit
              if git commit -m "chore(release): version bumps for ${{ steps.strategy.outputs.release_type }} release"; then
                echo "‚úÖ Changes committed"
              else
                echo "‚ö†Ô∏è No changes to commit (versions may already be correct)"
              fi
              
              # Create tags manually
              echo "üè∑Ô∏è Creating tags manually..."
              TAGS_CREATED=0
              for dir in apps libs packages; do
                if [ -d "$dir" ]; then
                  find "$dir" -maxdepth 2 -name "package.json" -type f | while read file; do
                    if [ -f "$file" ]; then
                      PROJECT_NAME=$(basename $(dirname "$file"))
                      VERSION=$(grep '"version"' "$file" | cut -d'"' -f4 2>/dev/null)
                      if [ -n "$VERSION" ] && [ "$VERSION" != "unknown" ]; then
                        TAG="${PROJECT_NAME}@${VERSION}"
                        if git tag -f "$TAG"; then
                          echo "üè∑Ô∏è Created tag: $TAG"
                          TAGS_CREATED=$((TAGS_CREATED + 1))
                        else
                          echo "‚ö†Ô∏è Failed to create tag $TAG"
                        fi
                      fi
                    fi
                  done
                fi
              done
              
              if [ $TAGS_CREATED -gt 0 ]; then
                echo "‚úÖ Created $TAGS_CREATED tag(s)"
              else
                echo "‚ö†Ô∏è No tags were created"
              fi
            else
              echo "‚ùå Both version commands failed"
              VERSION_SUCCESS=false
            fi
          fi

          # Step 2: Generate changelogs (only if version succeeded)
          if [ "$VERSION_SUCCESS" = "true" ]; then
            CHANGELOG_CMD="npx nx release changelog --verbose"
            if [ -n "${{ github.event.inputs.target_projects }}" ]; then
              CHANGELOG_CMD="$CHANGELOG_CMD --projects=${{ github.event.inputs.target_projects }}"
            fi
            
            echo "Executing changelog: $CHANGELOG_CMD"
            if $CHANGELOG_CMD; then
              echo "‚úÖ Changelog generation completed!"
            else
              echo "‚ö†Ô∏è Changelog generation failed, but continuing..."
              echo "This is often not critical for the release process"
            fi
            
            # Push changes
            echo "üì§ Pushing changes and tags..."
            if git push --follow-tags origin main; then
              echo "‚úÖ Successfully pushed changes and tags"
            else
              echo "‚ö†Ô∏è Push failed, but release may still be successful"
              echo "You may need to push manually: git push --follow-tags origin main"
            fi
            
            echo "‚úÖ NX Release process completed!"
          else
            echo "‚ùå Version bump failed completely"
            echo ""
            echo "üîç **Debugging Information:**"
            echo "Current working directory: $(pwd)"
            echo "Git status:"
            git status --porcelain || echo "Git status failed"
            echo ""
            echo "Current project versions:"
            for dir in apps libs packages; do
              if [ -d "$dir" ]; then
                find "$dir" -maxdepth 2 -name "package.json" -type f | while read file; do
                  if [ -f "$file" ]; then
                    PROJECT_NAME=$(basename $(dirname "$file"))
                    VERSION=$(grep '"version"' "$file" | cut -d'"' -f4 2>/dev/null || echo "unknown")
                    echo "  $PROJECT_NAME: $VERSION"
                  fi
                done
              fi
            done
            echo ""
            echo "üÜò **Manual Fix Required:**"
            echo "Run these commands locally to debug:"
            echo "  npx nx release --printConfig"
            echo "  npx nx release version ${{ steps.strategy.outputs.release_type }} --dry-run --verbose"
            echo "  npx nx release version ${{ steps.strategy.outputs.release_type }} --verbose --git-commit=false --git-tag=false"
            exit 1
          fi

      - name: Verify Release Results
        if: steps.analyze.outputs.needs_release == 'true'
        id: verify
        run: |
          echo "üîç Verifying release results..."

          # Check if any new tags were created
          NEW_TAGS=$(git tag --points-at HEAD | grep "@" || true)

          if [ -n "$NEW_TAGS" ]; then
            echo "‚úÖ New release tags created:"
            echo "$NEW_TAGS" | sed 's/^/  üè∑Ô∏è  /'
            echo "has_new_releases=true" >> $GITHUB_OUTPUT
            
            # Store new tags for use in GitHub releases
            echo "$NEW_TAGS" > /tmp/new_tags.txt
            
            echo ""
            echo "üì¶ Released project versions:"
            echo "$NEW_TAGS" | while read tag; do
              if [ -n "$tag" ]; then
                PROJECT=$(echo "$tag" | cut -d'@' -f1)
                VERSION=$(echo "$tag" | cut -d'@' -f2)
                echo "  $PROJECT: $VERSION"
              fi
            done
          else
            echo "‚ùå No new release tags found"
            echo "has_new_releases=false" >> $GITHUB_OUTPUT
          fi

          # Show what files were changed
          echo ""
          echo "üìù Files modified in this release:"
          git log -1 --name-only --pretty=format: | grep -E '\.(json|md)$' | sed 's/^/  üìÑ /' || echo "  No files modified"

      - name: Create GitHub Releases
        if: steps.verify.outputs.has_new_releases == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Creating GitHub releases..."

          # Read new tags from temporary file
          if [ ! -f "/tmp/new_tags.txt" ]; then
            echo "‚ùå No new tags file found"
            exit 1
          fi

          while read -r TAG; do
            if [ -n "$TAG" ] && echo "$TAG" | grep -q "@"; then
              PROJECT=$(echo "$TAG" | cut -d'@' -f1)
              VERSION=$(echo "$TAG" | cut -d'@' -f2)
              
              echo "Creating GitHub release for $PROJECT v$VERSION..."
              
              # Find changelog file for this project
              CHANGELOG_FILE=""
              for dir in "apps" "libs" "packages"; do
                if [ -f "$dir/$PROJECT/CHANGELOG.md" ]; then
                  CHANGELOG_FILE="$dir/$PROJECT/CHANGELOG.md"
                  break
                fi
              done
              
              # Extract release notes from changelog
              RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release was automatically generated from conventional commits."
              
              if [ -f "$CHANGELOG_FILE" ]; then
                echo "üìÑ Found changelog: $CHANGELOG_FILE"
                
                # Extract the content for this version
                VERSION_CONTENT=$(awk "
                  /^## .*$VERSION/ { flag=1; next }
                  /^## / && flag { exit }
                  flag && !/^$/ { print }
                " "$CHANGELOG_FILE" | head -50)
                
                if [ -n "$VERSION_CONTENT" ]; then
                  RELEASE_NOTES="$VERSION_CONTENT"
                else
                  RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release contains updates to $PROJECT."
                fi
              else
                echo "‚ö†Ô∏è  No changelog found for $PROJECT"
              fi
              
              # Create GitHub release (as draft for review)
              if gh release create "$TAG" \
                --draft \
                --title "$PROJECT v$VERSION" \
                --notes "$RELEASE_NOTES" \
                --generate-notes; then
                echo "‚úÖ Created draft release: $PROJECT v$VERSION"
              else
                echo "‚ùå Failed to create release for $TAG"
              fi
            fi
          done < /tmp/new_tags.txt

          echo ""
          echo "üéâ All GitHub releases created as drafts!"
          echo "üëÄ Review and publish at: https://github.com/${{ github.repository }}/releases"

      - name: Release Summary
        if: always()
        run: |
          echo ""
          echo "üìä Release Workflow Summary"
          echo "=========================="
          echo "üîß Triggered by: ${{ github.event_name }}"
          echo "üåü Release needed: ${{ steps.analyze.outputs.needs_release }}"
          echo "üéØ First release: ${{ steps.analyze.outputs.is_first_release }}"

          if [ "${{ steps.analyze.outputs.needs_release }}" == "true" ]; then
            if [ "${{ steps.verify.outputs.has_new_releases }}" == "true" ]; then
              echo "‚úÖ **SUCCESS**: Release completed!"
              echo ""
              echo "üè∑Ô∏è  **New Tags Created:**"
              git tag --points-at HEAD | grep "@" | sed 's/^/   ‚Ä¢ /' || echo "   None"
              echo ""
              echo "üìù **Next Steps:**"
              echo "   1. Review draft releases: https://github.com/${{ github.repository }}/releases"
              echo "   2. Publish releases when ready"
              echo "   3. Verify deployment pipelines (if any)"
            else
              echo "‚ö†Ô∏è  **WARNING**: Release was attempted but no new versions were created"
              echo ""
              echo "üîç **Debug Info:**"
              echo "   ‚Ä¢ Conventional commits detected: ‚úÖ"
              echo "   ‚Ä¢ Release type determined: ${{ steps.strategy.outputs.release_type || 'patch' }}"
              echo "   ‚Ä¢ This might indicate NX configuration issues"
              echo ""
              echo "üÜò **Manual Fix:**"
              if [ -n "${{ steps.strategy.outputs.release_type }}" ]; then
                echo "   npx nx release version ${{ steps.strategy.outputs.release_type }} --projects=router,home,shared"
              else
                echo "   npx nx release version patch --projects=router,home,shared"
              fi
            fi
          else
            echo "‚ÑπÔ∏è  **INFO**: No release needed"
            echo ""
            echo "üí° **To trigger a release, use conventional commits:**"
            echo "   ‚Ä¢ feat: new feature (minor bump)"
            echo "   ‚Ä¢ fix: bug fix (patch bump)"
            echo "   ‚Ä¢ feat!: breaking change (major bump)"
            echo "   ‚Ä¢ chore, docs, style, etc. (patch bump)"
            echo ""
            echo "üß™ **Test Examples:**"
            echo "   git commit -m \"fix: this should bump all projects\""
            echo "   git commit -m \"feat(router): add new navigation\""
            echo "   git commit -m \"feat!: redesign API\""
            echo ""
            echo "üîß **Or use manual trigger:**"
            echo "   ‚Ä¢ Go to Actions ‚Üí Release ‚Üí Run workflow"
            echo "   ‚Ä¢ Enable 'Force release' option"
          fi
