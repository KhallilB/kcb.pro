name: Release

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force release even if no conventional commits detected'
        required: false
        type: boolean
      target_projects:
        description: 'Specific projects to release (comma-separated, leave empty for all)'
        required: false
        default: ''
      release_type:
        description: 'Override release type (auto uses conventional commits)'
        required: false
        type: choice
        options:
          - auto
          - major
          - minor
          - patch
        default: auto

permissions:
  contents: write
  issues: write
  pull-requests: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Configure Git
        run: |
          git config --global user.name "release-bot"
          git config --global user.email "release-bot@users.noreply.github.com"

      - name: Install Dependencies
        run: npm install

      - name: Analyze Conventional Commits
        id: analyze
        run: |
          echo "üîç Analyzing conventional commits..."

          # Determine commit range to analyze
          if [ "${{ github.event_name }}" = "push" ]; then
            # For push events (including PR merges), check commits in the push
            if [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
              COMMIT_RANGE="${{ github.event.before }}..HEAD"
            else
              # First push to branch
              COMMIT_RANGE="HEAD~1..HEAD"
            fi
          else
            # For manual dispatch, check since last release per project
            COMMIT_RANGE="HEAD~10..HEAD"  # fallback range
          fi

          echo "üìã Analyzing commit range: $COMMIT_RANGE"

          # Show the commits we're analyzing
          echo "üìù Commits in range:"
          git log $COMMIT_RANGE --oneline | sed 's/^/  /'

          # Check for conventional commits in the range
          CONVENTIONAL_COMMITS=$(git log $COMMIT_RANGE --oneline --grep="^feat" --grep="^fix" --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --grep="^test" --grep="^build" --grep="^ci" --grep="^revert" --grep="BREAKING CHANGE" --extended-regexp)

          # Also check each commit message for conventional format (handles squash merges)
          MANUAL_CHECK_COMMITS=$(git log $COMMIT_RANGE --pretty=format:"%h %s" | grep -E "^[a-f0-9]+ (feat|fix|chore|docs|style|refactor|perf|test|build|ci)(\(.+\))?:")

          # Also check for conventional commits since last release for each project
          echo ""
          echo "üîç Checking per-project since last release:"
          PROJECT_HAS_CHANGES=false

          for project in router home shared; do
            LAST_TAG=$(git tag --list "${project}@*" --sort=-version:refname | head -1)
            if [ -n "$LAST_TAG" ]; then
              echo "  $project (since $LAST_TAG):"
              PROJECT_COMMITS=$(git log ${LAST_TAG}..HEAD --oneline --grep="^feat" --grep="^fix" --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --grep="^test" --grep="^build" --grep="^ci" --grep="BREAKING CHANGE" --extended-regexp)
              
              # Also check for any commits affecting this project's files
              PROJECT_FILE_CHANGES=$(git log ${LAST_TAG}..HEAD --oneline --name-only | grep -E "(apps/${project}/|libs/${project}/|packages/${project}/)" | wc -l)
              
              if [ -n "$PROJECT_COMMITS" ] || [ "$PROJECT_FILE_CHANGES" -gt 0 ]; then
                echo "    ‚úÖ Changes detected"
                if [ -n "$PROJECT_COMMITS" ]; then
                  echo "$PROJECT_COMMITS" | sed 's/^/      /'
                fi
                if [ "$PROJECT_FILE_CHANGES" -gt 0 ]; then
                  echo "      üìÅ $PROJECT_FILE_CHANGES file(s) changed"
                fi
                PROJECT_HAS_CHANGES=true
              else
                echo "    ‚ùå No changes detected"
              fi
            else
              echo "  $project: No previous releases (will release)"
              PROJECT_HAS_CHANGES=true
            fi
          done

          # Determine if release is needed
          NEEDS_RELEASE=false
          if [ -n "$CONVENTIONAL_COMMITS" ] || [ -n "$MANUAL_CHECK_COMMITS" ] || [ "$PROJECT_HAS_CHANGES" = "true" ]; then
            echo ""
            echo "‚úÖ Found changes requiring release:"
            [ -n "$CONVENTIONAL_COMMITS" ] && echo "$CONVENTIONAL_COMMITS" | sed 's/^/  üìù /'
            [ -n "$MANUAL_CHECK_COMMITS" ] && echo "$MANUAL_CHECK_COMMITS" | sed 's/^/  üîç /'
            NEEDS_RELEASE=true
          elif [ "${{ github.event.inputs.force_release }}" == "true" ]; then
            echo "‚úÖ Force release requested"
            NEEDS_RELEASE=true
          else
            echo "‚ùå No conventional commits or changes found"
          fi

          # Check if this is first release
          FIRST_RELEASE=false
          if ! git tag --list "*@*" | head -1 | grep -q "@"; then
            echo "üéâ First release detected"
            FIRST_RELEASE=true
            NEEDS_RELEASE=true
          fi

          # Set outputs
          echo "needs_release=$NEEDS_RELEASE" >> $GITHUB_OUTPUT
          echo "is_first_release=$FIRST_RELEASE" >> $GITHUB_OUTPUT
          echo "commit_range=$COMMIT_RANGE" >> $GITHUB_OUTPUT

          # Show current project versions
          echo ""
          echo "üì¶ Current project versions:"
          for dir in apps libs packages; do
            if [ -d "$dir" ]; then
              find "$dir" -maxdepth 2 -name "package.json" -type f | while read file; do
                if [ -f "$file" ]; then
                  PROJECT_NAME=$(basename $(dirname "$file"))
                  VERSION=$(grep '"version"' "$file" | cut -d'"' -f4 2>/dev/null || echo "unknown")
                  echo "  $PROJECT_NAME: $VERSION"
                fi
              done
            fi
          done

      - name: Determine Release Strategy
        if: steps.analyze.outputs.needs_release == 'true'
        id: strategy
        run: |
          echo "üéØ Determining release strategy..."

          # Analyze the types of conventional commits we found
          COMMIT_RANGE="${{ steps.analyze.outputs.commit_range }}"

          # Check for breaking changes
          BREAKING_CHANGES=$(git log $COMMIT_RANGE --grep="BREAKING CHANGE" --grep="!" --extended-regexp --oneline)

          # Check for features
          FEATURES=$(git log $COMMIT_RANGE --grep="^feat" --extended-regexp --oneline)

          # Check for fixes and other changes
          FIXES=$(git log $COMMIT_RANGE --grep="^fix" --extended-regexp --oneline)
          OTHER_CHANGES=$(git log $COMMIT_RANGE --grep="^chore" --grep="^docs" --grep="^style" --grep="^refactor" --grep="^perf" --extended-regexp --oneline)

          # Determine version bump type
          if [ -n "$BREAKING_CHANGES" ]; then
            RELEASE_TYPE="major"
            echo "üìà Detected breaking changes - will use MAJOR version bump"
          elif [ -n "$FEATURES" ]; then
            RELEASE_TYPE="minor"
            echo "üìà Detected features - will use MINOR version bump"
          elif [ -n "$FIXES" ] || [ -n "$OTHER_CHANGES" ]; then
            RELEASE_TYPE="patch"
            echo "üìà Detected fixes/changes - will use PATCH version bump"
          else
            RELEASE_TYPE="patch"
            echo "üìà Default to PATCH version bump"
          fi

          # Override if manual release type specified
          if [ "${{ github.event.inputs.release_type }}" != "auto" ] && [ -n "${{ github.event.inputs.release_type }}" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            echo "üéõÔ∏è Manual override: using $RELEASE_TYPE version bump"
          fi

          echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
          echo "‚úÖ Will use release type: $RELEASE_TYPE"

      - name: Run NX Release
        if: steps.analyze.outputs.needs_release == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NX_CLOUD_ACCESS_TOKEN: ${{ secrets.NX_CLOUD_ACCESS_TOKEN }}
        run: |
          echo "üöÄ Running NX Release..."

          # Since we detected changes but NX might not, use individual commands
          # This is more reliable than the combined `nx release` command

          echo "üîÑ Using individual NX release commands for better control..."

          # Step 1: Version bump
          VERSION_CMD="npx nx release version ${{ steps.strategy.outputs.release_type }} --verbose"

          # Add target projects if specified
          if [ -n "${{ github.event.inputs.target_projects }}" ]; then
            VERSION_CMD="$VERSION_CMD --projects=${{ github.event.inputs.target_projects }}"
            echo "üéØ Targeting specific projects: ${{ github.event.inputs.target_projects }}"
          fi

          # Add first release flag if needed
          if [ "${{ steps.analyze.outputs.is_first_release }}" == "true" ]; then
            VERSION_CMD="$VERSION_CMD --first-release"
            echo "üéâ Running first release"
          fi

          echo "Executing version: $VERSION_CMD"
          if $VERSION_CMD; then
            echo "‚úÖ Version bump completed successfully!"
            
            # Step 2: Generate changelogs
            CHANGELOG_CMD="npx nx release changelog --verbose"
            if [ -n "${{ github.event.inputs.target_projects }}" ]; then
              CHANGELOG_CMD="$CHANGELOG_CMD --projects=${{ github.event.inputs.target_projects }}"
            fi
            
            echo "Executing changelog: $CHANGELOG_CMD"
            if $CHANGELOG_CMD; then
              echo "‚úÖ Changelog generation completed!"
            else
              echo "‚ö†Ô∏è Changelog generation had warnings (this is normal for some setups)"
            fi
            
            echo "‚úÖ NX Release process completed successfully!"
          else
            echo "‚ùå Version bump failed"
            echo "This might indicate:"
            echo "  ‚Ä¢ Projects don't have package.json files"
            echo "  ‚Ä¢ Git working directory is not clean"
            echo "  ‚Ä¢ NX configuration issues"
            exit 1
          fi

      - name: Verify Release Results
        if: steps.analyze.outputs.needs_release == 'true'
        id: verify
        run: |
          echo "üîç Verifying release results..."

          # Check if any new tags were created
          NEW_TAGS=$(git tag --points-at HEAD | grep "@" || true)

          if [ -n "$NEW_TAGS" ]; then
            echo "‚úÖ New release tags created:"
            echo "$NEW_TAGS" | sed 's/^/  üè∑Ô∏è  /'
            echo "has_new_releases=true" >> $GITHUB_OUTPUT
            
            # Store new tags for use in GitHub releases
            echo "$NEW_TAGS" > /tmp/new_tags.txt
            
            echo ""
            echo "üì¶ Released project versions:"
            echo "$NEW_TAGS" | while read tag; do
              if [ -n "$tag" ]; then
                PROJECT=$(echo "$tag" | cut -d'@' -f1)
                VERSION=$(echo "$tag" | cut -d'@' -f2)
                echo "  $PROJECT: $VERSION"
              fi
            done
          else
            echo "‚ùå No new release tags found"
            echo "has_new_releases=false" >> $GITHUB_OUTPUT
          fi

          # Show what files were changed
          echo ""
          echo "üìù Files modified in this release:"
          git log -1 --name-only --pretty=format: | grep -E '\.(json|md)$' | sed 's/^/  üìÑ /' || echo "  No files modified"

      - name: Create GitHub Releases
        if: steps.verify.outputs.has_new_releases == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üìù Creating GitHub releases..."

          # Read new tags from temporary file
          if [ ! -f "/tmp/new_tags.txt" ]; then
            echo "‚ùå No new tags file found"
            exit 1
          fi

          while read -r TAG; do
            if [ -n "$TAG" ] && echo "$TAG" | grep -q "@"; then
              PROJECT=$(echo "$TAG" | cut -d'@' -f1)
              VERSION=$(echo "$TAG" | cut -d'@' -f2)
              
              echo "Creating GitHub release for $PROJECT v$VERSION..."
              
              # Find changelog file for this project
              CHANGELOG_FILE=""
              for dir in "apps" "libs" "packages"; do
                if [ -f "$dir/$PROJECT/CHANGELOG.md" ]; then
                  CHANGELOG_FILE="$dir/$PROJECT/CHANGELOG.md"
                  break
                fi
              done
              
              # Extract release notes from changelog
              RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release was automatically generated from conventional commits."
              
              if [ -f "$CHANGELOG_FILE" ]; then
                echo "üìÑ Found changelog: $CHANGELOG_FILE"
                
                # Extract the content for this version
                VERSION_CONTENT=$(awk "
                  /^## .*$VERSION/ { flag=1; next }
                  /^## / && flag { exit }
                  flag && !/^$/ { print }
                " "$CHANGELOG_FILE" | head -50)
                
                if [ -n "$VERSION_CONTENT" ]; then
                  RELEASE_NOTES="$VERSION_CONTENT"
                else
                  RELEASE_NOTES="üöÄ **Release $VERSION**"$'\n\n'"This release contains updates to $PROJECT."
                fi
              else
                echo "‚ö†Ô∏è  No changelog found for $PROJECT"
              fi
              
              # Create GitHub release (as draft for review)
              if gh release create "$TAG" \
                --draft \
                --title "$PROJECT v$VERSION" \
                --notes "$RELEASE_NOTES" \
                --generate-notes; then
                echo "‚úÖ Created draft release: $PROJECT v$VERSION"
              else
                echo "‚ùå Failed to create release for $TAG"
              fi
            fi
          done < /tmp/new_tags.txt

          echo ""
          echo "üéâ All GitHub releases created as drafts!"
          echo "üëÄ Review and publish at: https://github.com/${{ github.repository }}/releases"

      - name: Release Summary
        if: always()
        run: |
          echo ""
          echo "üìä Release Workflow Summary"
          echo "=========================="
          echo "üîß Triggered by: ${{ github.event_name }}"
          echo "üåü Release needed: ${{ steps.analyze.outputs.needs_release }}"
          echo "üéØ First release: ${{ steps.analyze.outputs.is_first_release }}"

          if [ "${{ steps.analyze.outputs.needs_release }}" == "true" ]; then
            if [ "${{ steps.verify.outputs.has_new_releases }}" == "true" ]; then
              echo "‚úÖ **SUCCESS**: Release completed!"
              echo ""
              echo "üè∑Ô∏è  **New Tags Created:**"
              git tag --points-at HEAD | grep "@" | sed 's/^/   ‚Ä¢ /' || echo "   None"
              echo ""
              echo "üìù **Next Steps:**"
              echo "   1. Review draft releases: https://github.com/${{ github.repository }}/releases"
              echo "   2. Publish releases when ready"
              echo "   3. Verify deployment pipelines (if any)"
            else
              echo "‚ö†Ô∏è  **WARNING**: Release was attempted but no new versions were created"
              echo ""
              echo "üîç **Debug Info:**"
              echo "   ‚Ä¢ Conventional commits detected: ‚úÖ"
              echo "   ‚Ä¢ Release type determined: ${{ steps.strategy.outputs.release_type || 'patch' }}"
              echo "   ‚Ä¢ This might indicate NX configuration issues"
              echo ""
              echo "üÜò **Manual Fix:**"
              if [ -n "${{ steps.strategy.outputs.release_type }}" ]; then
                echo "   npx nx release version ${{ steps.strategy.outputs.release_type }} --projects=router,home,shared"
              else
                echo "   npx nx release version patch --projects=router,home,shared"
              fi
            fi
          else
            echo "‚ÑπÔ∏è  **INFO**: No release needed"
            echo ""
            echo "üí° **To trigger a release, use conventional commits:**"
            echo "   ‚Ä¢ feat: new feature (minor bump)"
            echo "   ‚Ä¢ fix: bug fix (patch bump)"
            echo "   ‚Ä¢ feat!: breaking change (major bump)"
            echo "   ‚Ä¢ chore, docs, style, etc. (patch bump)"
            echo ""
            echo "üß™ **Test Examples:**"
            echo "   git commit -m \"fix: this should bump all projects\""
            echo "   git commit -m \"feat(router): add new navigation\""
            echo "   git commit -m \"feat!: redesign API\""
            echo ""
            echo "üîß **Or use manual trigger:**"
            echo "   ‚Ä¢ Go to Actions ‚Üí Release ‚Üí Run workflow"
            echo "   ‚Ä¢ Enable 'Force release' option"
          fi
